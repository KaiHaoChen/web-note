视频链接：[【JavaScript核心基础_讲师（李立超）_JS教程】](https://www.bilibili.com/video/BV1mG411h7aD?vd_source=ef643319126f7224463297380162bd6c)
[toc]

# 基本语法
## 注释
- 单行注释 //
- 多行注释 /*  内容 */

## 变量
- 声明变量： let  变量名
- 变量赋值： a = xxx
- 声明赋值 let 变量 = 值

## 常量
- 声明常量： const 常量名
- 常量声明后不能修改

## 标识符
- 标识符只能含有字母、数字、下划线、$、且不能以数字开头
- 不能使用js关键字和保留字
- 命名规范：驼峰命名（首字母大写，每个单词开头大写）

## 数据类型
### Number
- JS中的所有整数和浮点数都是Number类型
- Infinity 是一个特殊的数值表示无穷
- NaN 表示非法的数值
- 大整数使用n结尾

### 类型
- typeof 用来检查不同的值的类型

### 字符串
- 使用单引号和双引号来表示字符串
- 转义字符 \
- 模板字符串
```
- 使用反单引号表示 `
- 模板字符串可以嵌入变量
```

### boolean
- 布尔值只有两个true 和 false

### null
- 空值用来表示空对象

### undefined
- 声明变量没有赋值，它的值就是undefined

### symbol
- 用来创建唯一的标识

## 类型转换
### 字符串
- 调用toString()方法将其他类型转换为字符串
- 调用String()函数将其他类型转换为字符串

### 数字
- 使用Number()函数来将其他类型转换为数值
```
- 字符串
    如果字符串是合法的数字则直接转换为数字
    如果字符串不是合法数字则转换为NaN
    如果字符串是空或空格，则转换为0
- 布尔
    true转换1   false转换0
- null转换0
- undefined转换为NaN

```
- parseInt() - 将字符串转换为整数
```
解析时，会自左向右读取字符串，直到读取字符串中的整数0
```
- parseFloat() - 将字符串转换为浮点数
### 布尔
- 使用Boolean()函数来将其他类型转换为布尔值
```
数字：
    除了0和NaN 转换为false
    其余为true
字符串：
    空串转换为false
    其余为false
null和undefined 都转换为false
```

## 对象
```
- 添加属性：对象.属性名 = 属性值
- 读取属性：对象.属性名，如果没有返回undefined
- 删除属性 delete 对象.属性名

```
### 属性
- 属性名使用驼峰命名
- 使用[]去操作属性，可以使用变量

### 枚举对象
- for-in语句
- for-in有几个属性执行几次
```
for(let propName in 对象){

}
```
### 可变类型
- 当两个对象相等或者全等，比较的是内存地址
- 如果两个对象指向同一个对象，通过一个变量修改对象，例外一个也会影响

### 变量和对象
- 防止对象被重新赋值，！！使用const申明对象

### 方法
- 当一个对象的属性指向一个函数，那么我们就称这个函数是该对象的方法
## 函数
- 函数也是对象  
```
创建函数对象
    function() 函数名{}
调用函数
    函数对象（）
```

### 函数创建方式
- 函数申明
```
function() 函数名{}
```
- 函数表达式
```
const fn2 = function(){}
```
- 箭头函数
```
const fn3 = （）=> {}
```
### 函数参数
#### 参数定义
- 如果实参和形参的数量相同，则对应
- 如果实参多余形参，则多余的实参不会使用
- 如果形参多余实参，则多余的形参undefined

#### 箭头函数
- 当箭头函数只有一个参数时，可以省略（）
- 定义参数的时候可以指定默认值,没有传参是就使用默认值
```
const fn = (a=10) => {}

```
#### 对象参数
- 对象作为参数传递，传递的是内存地址

#### 函数参数
- 函数也是对象，也可以作为参数传递

### 函数返回值
- 使用return关键字来指定函数的返回值
- 箭头函数的返回值可以直接写在箭头后

### 作用域
- 全局作用域
```
- 全局作用域在网页运行时创建，在网页关闭时消耗
- 所有直接编写在script标签中的代码都位于全局作用域中
- 全局作用域中的变量，可以在任意位置访问
```
- 局部作用域
```
- 块作用域在代码块执行的时创建，代码块执行完毕他就销毁
- 块作用域声明的变量为局部变量，外部无法访问
```
- 函数作用域
```
- 函数作用域在函数调用时产生
- 函数定义的变量为局部变量
- 函数每次调用都是一个全新的作用域
```
### 作用域链
```
当我们使用一个变量时，js会优先使用当前作用域中的变量，如果没有找到则去上一层作用域寻找
```

### window对象
- 浏览器为我们提供window对象
- 除了window对象还负责存储js中的内置对象和浏览器的宿主对象
- window对象的属性可以通过window对象访问，也可以直接访问

### var
- 使用var定义的变量，都会作为window对象的属性保存
- 使用let声明的变量不会存储在window对象
- var虽然没有块作用域，但又函数作用域


### 提升
- 使用var声明的变量，他会在所有的代码执行前声明
- 函数声明创建的函数，会在其他代码执行前创建
- let声明的变量实际也提升，但是赋值之前禁止访问

### 立即执行函数
- 立即是一个匿名函数，它只会调用一次
```
(function(){}());
```
### 函数中的this
- this会指向一个对象
- this所指向的this会根据函数调用的方式不同而不同
```
- 以函数形式调用，this指向的是window
- 以方法的形式调用时，this指向的是调用方法的对象
```
- 箭头函数的this总是指向上一层作用域的this

### 严格模式
- "use strict"

## 面向对象
```
class Dog {

}
const d1 = new Dog()
```
### 属性
- 使用static声明的属性，是静态属性,只能通过类去访问
```
class Person {
    age
    name
}
```
### 方法
```
class Person {
    name = "ckh"

    sayHello(){

    }
}
```
### 构造方法
- constructor
- 构造函数会在调用类创建对象时执行
```
class Person {
    name
    constructor(name){
        this.name = name;
    }
}
```
### 封装
- 通过#将属性设置为私有
- 通过get set方法来操作属性
- 封装保证数据的安全
```
class Person {
    #name
    constructor(name){
        this.#name = name;
    }

    getName(){
        return this.#name;
    }

    setName(name){
        this.#name = name;
    }
}
```

### 多态
- 灵活性
```
function sayHello(obj){

}
sayHello(new Dog())
```

### 继承
- extend
- super 父类
- ocp开闭原则
```
修改关闭，扩展开放
```
```
class Animal {
    constructor(name){
        this.name = name
    }

    sayHello(){

    }
}

class Dog extend Animal {

}
```

### 对象结构
- 对象自身
- 原型对象_proto_  
```
1.在类中通过xxx(){}方式添加的方法
2.主动向原型中添加属性和方法
```
### 原型
- 访问原型对象
```
对象.__proto__ 
Object.getPrototypeOf(对象)
```
- 原型对象中的数据
```
1.对象中的属性和方法
2.constructor

注意：原型对象也有原型
p对象 - 原型 - 原型 - null
obj对象 - 原型 - null
```
### 原型的作用
- 同类型的对象原型对象都是同一个
- 避免重复创建方法
- 继承：子类的原型就是父类


p83